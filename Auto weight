Argument #1 expects a string, but Instance was passed

means that somewhere in your code (or possibly in how the remote function is being used), you're passing an Instance (like a Part, Model, or Folder) instead of a string.


---

🔍 From the stack trace:

Script ReplicatedStorage.Modules.Numbers Line 458 function GetCurrentDimension
Script ReplicatedStorage.Modules.Numbers Line 473 function HasWins
Script Players.XPhantom_xdemonx.PlayerGui.ZoneGui.Client Line 78 function UpdateDoors

The important line in your script appears to be:

Script Players.XPhantom_xdemonx.PlayerGui.ZoneGui.Client Line 78

This suggests that UpdateDoors or collectRemote:FireServer(world) is sending an Instance instead of the expected world name (string).


---

✅ What to check

In your code:

for _, world in ipairs(possibleWorlds) do
	collectRemote:FireServer(world)
end

Make sure that possibleWorlds really only contains strings. From your original code, they are strings, so that part looks fine.

So, what could be going wrong?


---

⚠️ Potential issues:

1. Is collectRemote correct?

Check that collectRemote is really a RemoteEvent, not a folder or module.

Confirm it's being located properly in this line:

local collectRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("WeightSpawnHandler"):WaitForChild("Collect")

✅ Double-check:

Modules is a Folder

WeightSpawnHandler is a Folder

Collect is a RemoteEvent


If Collect is accidentally a ModuleScript or Folder, it would be an Instance, which could break everything.



2. The server-side OnServerEvent might be mishandling the input.

Example (on the server):

collectRemote.OnServerEvent:Connect(function(player, worldName)
    -- Check what type worldName is
    print(typeof(worldName)) -- Should be "string"
end)

If worldName is an Instance, that's your problem.





---

✅ Solution Steps

1. Check Collect remote is actually a RemoteEvent

Go to Explorer in Roblox Studio:

ReplicatedStorage > Modules > WeightSpawnHandler > Collect

Confirm that Collect is a RemoteEvent, not a Folder or ModuleScript.




2. Print debug output Add a debug line before the FireServer call:

for _, world in ipairs(possibleWorlds) do
    print("Firing server with world:", world, typeof(world))
    collectRemote:FireServer(world)
    task.wait(0.2)
end

This will confirm if world is really a string.


3. Check server-side code Wherever collectRemote.OnServerEvent is being handled, print out the incoming argument:

collectRemote.OnServerEvent:Connect(function(player, world)
    print("Received:", world, typeof(world))
    -- Must be a string
